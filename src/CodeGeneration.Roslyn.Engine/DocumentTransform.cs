// Copyright (c) Andrew Arnott. All rights reserved.
// Licensed under the MS-PL license. See LICENSE.txt file in the project root for full license information.

namespace CodeGeneration.Roslyn.Engine
{
    using System;
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Linq;
    using System.Reflection;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Validation;

    /// <summary>
    /// The class responsible for generating compilation units to add to the project being built.
    /// </summary>
    public static class DocumentTransform
    {
        /// <summary>
        /// A "generated by tool" comment string with environment/os-normalized newlines.
        /// </summary>
        public static readonly string GeneratedByAToolPreamble = @"// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
".Replace("\r\n", "\n").Replace("\n", Environment.NewLine); // normalize regardless of git checkout policy

        /// <summary>
        /// Produces a new document in response to any code generation attributes found in the specified document.
        /// </summary>
        /// <param name="compilation">The compilation to which the document belongs.</param>
        /// <param name="inputDocument">The document to scan for generator attributes.</param>
        /// <param name="projectDirectory">The path of the <c>.csproj</c> project file.</param>
        /// <param name="buildProperties">MSBuild properties to expose to the generator.</param>
        /// <param name="assemblyLoader">A function that can load an assembly with the given name.</param>
        /// <param name="progress">Reports warnings and errors in code generation.</param>
        /// <param name="cancellationToken">The token to monitor for cancellation requests.</param>
        /// <returns>A task whose result is the generated document.</returns>
        public static async Task<SyntaxTree> TransformAsync(
            CSharpCompilation compilation,
            SyntaxTree inputDocument,
            string? projectDirectory,
            IReadOnlyDictionary<string, string> buildProperties,
            Func<AssemblyName, Assembly?> assemblyLoader,
            IProgress<Diagnostic> progress,
            CancellationToken cancellationToken)
        {
            Requires.NotNull(compilation, nameof(compilation));
            Requires.NotNull(inputDocument, nameof(inputDocument));
            Requires.NotNull(assemblyLoader, nameof(assemblyLoader));

            var inputSemanticModel = compilation.GetSemanticModel(inputDocument);
            var inputCompilationUnit = inputDocument.GetCompilationUnitRoot();

            var emittedExterns = inputCompilationUnit
                .Externs
                .Select(x => x.WithoutTrivia())
                .ToImmutableArray();

            var emittedUsings = inputCompilationUnit
                .Usings
                .Select(x => x.WithoutTrivia())
                .ToImmutableArray();

            var emittedAttributeLists = ImmutableArray<AttributeListSyntax>.Empty;
            var emittedMembers = ImmutableArray<MemberDeclarationSyntax>.Empty;

            var root = await inputDocument.GetRootAsync(cancellationToken);
            var memberNodes = root
                .DescendantNodesAndSelf(n => n is CompilationUnitSyntax || n is NamespaceDeclarationSyntax || n is TypeDeclarationSyntax)
                .OfType<CSharpSyntaxNode>();

            foreach (var memberNode in memberNodes)
            {
                cancellationToken.ThrowIfCancellationRequested();
                
                var generators = FindCodeGenerators(compilation, inputSemanticModel, memberNode, assemblyLoader);
                foreach (var generator in generators)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    var context = new TransformationContext(
                        memberNode,
                        inputSemanticModel,
                        compilation,
                        projectDirectory,
                        emittedUsings,
                        emittedExterns,
                        buildProperties);

                    var richGenerator = generator as IRichCodeGenerator ?? new EnrichingCodeGeneratorProxy(generator);

                    var emitted = await richGenerator.GenerateRichAsync(context, progress, cancellationToken);

                    emittedExterns = emittedExterns.AddRange(emitted.Externs);
                    emittedUsings = emittedUsings.AddRange(emitted.Usings);
                    emittedAttributeLists = emittedAttributeLists.AddRange(emitted.AttributeLists);
                    emittedMembers = emittedMembers.AddRange(emitted.Members);
                }
            }

            var compilationUnit =
                SyntaxFactory.CompilationUnit(
                        SyntaxFactory.List(emittedExterns),
                        SyntaxFactory.List(emittedUsings),
                        SyntaxFactory.List(emittedAttributeLists),
                        SyntaxFactory.List(emittedMembers))
                    .WithLeadingTrivia(SyntaxFactory.Comment(GeneratedByAToolPreamble))
                    .WithTrailingTrivia(SyntaxFactory.CarriageReturnLineFeed)
                    .NormalizeWhitespace();

            return compilationUnit.SyntaxTree;
        }

        public static async Task<bool> HasCodeGenerators(
            CSharpCompilation compilation,
            SyntaxTree inputDocument,
            CancellationToken cancellationToken)
        {
            var inputSemanticModel = compilation.GetSemanticModel(inputDocument);
            var root = await inputDocument.GetRootAsync(cancellationToken);
            var memberNodes = root
                .DescendantNodesAndSelf(n =>
                    n is CompilationUnitSyntax || n is NamespaceDeclarationSyntax || n is TypeDeclarationSyntax)
                .OfType<CSharpSyntaxNode>();

            foreach (var memberNode in memberNodes)
            {
                cancellationToken.ThrowIfCancellationRequested();
                var attributeData = GetInheritedAttributeData(compilation, inputSemanticModel, memberNode);
                if (HasCodeGenerators(attributeData))
                {
                    return true;
                }
            }

            return false;
        }

        private static bool HasCodeGenerators(ImmutableArray<AttributeData> nodeAttributes)
        {
            foreach (var attributeData in nodeAttributes)
            {
                if (HasCodeGeneratorTypeForAttribute(attributeData.AttributeClass, out _))
                {
                    return true;
                }
            }

            return false;
        }

        private static bool HasCodeGeneratorTypeForAttribute(INamedTypeSymbol attributeType, out AttributeData generatorAttribute)
        {
            foreach (var generatorCandidateAttribute in attributeType.GetAttributes())
            {
                if (generatorCandidateAttribute.AttributeClass.Name == typeof(CodeGenerationAttributeAttribute).Name)
                {
                    generatorAttribute = generatorCandidateAttribute;
                    return true;
                }
            }

            generatorAttribute = null;
            return false;
        }

        private static ImmutableArray<AttributeData> GetAttributeData(Compilation compilation, SemanticModel document, SyntaxNode syntaxNode)
        {
            Requires.NotNull(compilation, nameof(compilation));
            Requires.NotNull(document, nameof(document));
            Requires.NotNull(syntaxNode, nameof(syntaxNode));

            switch (syntaxNode)
            {
                case CompilationUnitSyntax syntax:
                    return compilation.Assembly.GetAttributes().Where(x => x.ApplicationSyntaxReference.SyntaxTree == syntax.SyntaxTree).ToImmutableArray();
                default:
                    return document.GetDeclaredSymbol(syntaxNode)?.GetAttributes() ?? ImmutableArray<AttributeData>.Empty;
            }
        }

        private static ImmutableArray<AttributeData> GetInheritedAttributeData(Compilation compilation, SemanticModel document, SyntaxNode syntaxNode)
        {
            Requires.NotNull(compilation, nameof(compilation));
            Requires.NotNull(document, nameof(document));
            Requires.NotNull(syntaxNode, nameof(syntaxNode));

            switch (syntaxNode)
            {
                case CompilationUnitSyntax syntax:
                    return compilation.Assembly.GetAttributes().Where(x => x.ApplicationSyntaxReference.SyntaxTree == syntax.SyntaxTree).ToImmutableArray();
                default:
                {
                    ImmutableArray<AttributeData> ret = ImmutableArray<AttributeData>.Empty;
                    ITypeSymbol? t = document.GetDeclaredSymbol(syntaxNode) as ITypeSymbol;

                    if (t == null)
                    {
                        return ret;
                    }

                    do
                    {
                        ret = ret.AddRange(t.GetAttributes());
                        t = t.BaseType;

                    } while (t != null && t.SpecialType != SpecialType.System_Object);

                    return ret;
                }
            }
        }
        
        private static IEnumerable<ICodeGenerator> FindCodeGenerators(Compilation compilation, SemanticModel document, SyntaxNode syntaxNode, Func<AssemblyName, Assembly?> assemblyLoader)
        {
            List<ICodeGenerator> codeGenerators = new List<ICodeGenerator>();

            var generatorTypeResult = GetCodeGeneratorTypeForAttribute(compilation, document, syntaxNode, assemblyLoader);

            if (generatorTypeResult != null)
            {
                ICodeGenerator generator;
                try
                {
                    generator = (ICodeGenerator)Activator.CreateInstance(generatorTypeResult.GeneratorType, generatorTypeResult.CandidateAttribute);

                    codeGenerators.Add(generator);
                }
                catch (MissingMethodException)
                {
                    throw new InvalidOperationException(
                        $"Failed to instantiate {generatorTypeResult}. ICodeGenerator implementations must have" +
                        $" a constructor accepting Microsoft.CodeAnalysis.AttributeData argument.");
                }

            }

            return codeGenerators;
        }

        private class GeneratorTypeResult
        {
            public Type GeneratorType { get; }
            public AttributeData CandidateAttribute { get; }

            public GeneratorTypeResult(Type generatorType, AttributeData candidateAttribute)
            {
                GeneratorType = generatorType;
                CandidateAttribute = candidateAttribute;
            }
        }
        

        private static GeneratorTypeResult GetCodeGeneratorTypeForAttribute(Compilation compilation, SemanticModel document, SyntaxNode syntaxNode, Func<AssemblyName, Assembly?> assemblyLoader)
        {
            foreach (var candidateAttribute in GetInheritedAttributeData(compilation, document, syntaxNode))
            {
                if (HasCodeGeneratorTypeForAttribute(candidateAttribute.AttributeClass, out AttributeData generatorCandidateAttribute))
                {
                    Logger.Info($"Code generation attribute {candidateAttribute} found.");

                    string? assemblyName = null;
                    string? fullTypeName = null;
                    TypedConstant firstArg = generatorCandidateAttribute.ConstructorArguments.Single();
                    if (firstArg.Value is string typeName)
                    {
                        // This string is the full name of the type, which MAY be assembly-qualified.
                        int commaIndex = typeName.IndexOf(',');
                        bool isAssemblyQualified = commaIndex >= 0;
                        if (isAssemblyQualified)
                        {
                            fullTypeName = typeName.Substring(0, commaIndex);
                            assemblyName = typeName.Substring(commaIndex + 1).Trim();
                        }
                        else
                        {
                            fullTypeName = typeName;
                            assemblyName = generatorCandidateAttribute.AttributeClass.ContainingAssembly.Name;
                        }
                    }
                    else if (firstArg.Value is INamedTypeSymbol typeOfValue)
                    {
                        // This was a typeof(T) expression
                        fullTypeName = GetFullTypeName(typeOfValue);
                        assemblyName = typeOfValue.ContainingAssembly.Name;
                    }

                    if (assemblyName != null)
                    {
                        var assembly = assemblyLoader(new AssemblyName(assemblyName));
                        if (assembly != null)
                        {
                            var generatorType = assembly.GetType(fullTypeName);
                            return new GeneratorTypeResult(generatorType, candidateAttribute);
                        }
                        else
                        {
                            Verify.FailOperation("Unable to find code generator: {0} in {1}", fullTypeName, assemblyName);
                        }
                    }
                    else
                    {
                        Verify.FailOperation("Unable to find code generator: {0}. Containing assembly not found.", fullTypeName);
                    }
                }
                else
                {
                    Logger.Info($"Attribute {candidateAttribute} found. Is not a code generation attribute.");
                }
            }

            return null;
        }

        private static string GetFullTypeName(INamedTypeSymbol symbol)
        {
            Requires.NotNull(symbol, nameof(symbol));

            var nameBuilder = new StringBuilder();
            ISymbol symbolOrParent = symbol;
            while (symbolOrParent != null && !string.IsNullOrEmpty(symbolOrParent.Name))
            {
                if (nameBuilder.Length > 0)
                {
                    nameBuilder.Insert(0, ".");
                }

                nameBuilder.Insert(0, symbolOrParent.Name);
                symbolOrParent = symbolOrParent.ContainingSymbol;
            }

            return nameBuilder.ToString();
        }

        private class EnrichingCodeGeneratorProxy : IRichCodeGenerator
        {
            public EnrichingCodeGeneratorProxy(ICodeGenerator codeGenerator)
            {
                Requires.NotNull(codeGenerator, nameof(codeGenerator));
                CodeGenerator = codeGenerator;
            }

            private ICodeGenerator CodeGenerator { get; }

            public Task<SyntaxList<MemberDeclarationSyntax>> GenerateAsync(
                TransformationContext context,
                IProgress<Diagnostic> progress,
                CancellationToken cancellationToken)
            {
                return CodeGenerator.GenerateAsync(context, progress, cancellationToken);
            }

            public async Task<RichGenerationResult> GenerateRichAsync(TransformationContext context, IProgress<Diagnostic> progress, CancellationToken cancellationToken)
            {
                var generatedMembers = await CodeGenerator.GenerateAsync(context, progress, cancellationToken);

                // Figure out ancestry for the generated type, including nesting types and namespaces.
                var wrappedMembers = context.ProcessingNode.Ancestors().Aggregate(generatedMembers, WrapInAncestor);
                return new RichGenerationResult { Members = wrappedMembers };
            }

            private static SyntaxList<MemberDeclarationSyntax> WrapInAncestor(SyntaxList<MemberDeclarationSyntax> generatedMembers, SyntaxNode ancestor)
            {
                switch (ancestor)
                {
                    case NamespaceDeclarationSyntax ancestorNamespace:
                        generatedMembers = SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                            CopyAsAncestor(ancestorNamespace)
                            .WithMembers(generatedMembers));
                        break;
                    case ClassDeclarationSyntax nestingClass:
                        generatedMembers = SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                            CopyAsAncestor(nestingClass)
                            .WithMembers(generatedMembers));
                        break;
                    case StructDeclarationSyntax nestingStruct:
                        generatedMembers = SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                            CopyAsAncestor(nestingStruct)
                            .WithMembers(generatedMembers));
                        break;
                }
                return generatedMembers;
            }

            private static NamespaceDeclarationSyntax CopyAsAncestor(NamespaceDeclarationSyntax syntax)
            {
                return SyntaxFactory.NamespaceDeclaration(syntax.Name.WithoutTrivia())
                    .WithExterns(SyntaxFactory.List(syntax.Externs.Select(x => x.WithoutTrivia())))
                    .WithUsings(SyntaxFactory.List(syntax.Usings.Select(x => x.WithoutTrivia())));
            }

            private static ClassDeclarationSyntax CopyAsAncestor(ClassDeclarationSyntax syntax)
            {
                return SyntaxFactory.ClassDeclaration(syntax.Identifier.WithoutTrivia())
                    .WithModifiers(SyntaxFactory.TokenList(syntax.Modifiers.Select(x => x.WithoutTrivia())))
                    .WithTypeParameterList(syntax.TypeParameterList);
            }

            private static StructDeclarationSyntax CopyAsAncestor(StructDeclarationSyntax syntax)
            {
                return SyntaxFactory.StructDeclaration(syntax.Identifier.WithoutTrivia())
                    .WithModifiers(SyntaxFactory.TokenList(syntax.Modifiers.Select(x => x.WithoutTrivia())))
                    .WithTypeParameterList(syntax.TypeParameterList);
            }
        }
    }
}
